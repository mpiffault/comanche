#!/usr/bin/perl

use Socket;
use POSIX qw(:sys_wait_h strftime);

$EOL = "\015\012";
$EOR = $EOL x 2;
$pidFile = ".comanche.pid";

$ARGV[0] =~ /^(start|stop|status)$/ or printusage();
$action = $ARGV[0];

@relative_route;
@absolute_route;

@relative_exec;
@absolute_exec;

%reason_phrases = (
    200, "OK",
    400, "Bad Request",
    503, "Service Unavailable"
    );

%signaux = (
    status, "USR1",
    stop, "USR2"
    );

# prise en compte des la mort des ouvriers
$SIG{CHLD} = \&FOSSOYEUR;
$SIG{$signaux{status}} = \&PRINTSTATUS;
$SIG{$signaux{stop}} = \&STOPDAEMON;

select STDOUT;
$| = 1;

$action =~ /^start$/ && do {(-f $pidFile) ? print "Un instance de comanche existe déjà.\n" : startDaemon()};

$action =~ /^(status|stop)$/ && do {(-f $pidFile) ? sendSignal($signaux{$action}) : print "Le service n'est pas démarré.\n"};

sub printusage
{
    print "$0 [start|stop]\n";
    exit 1;
}

sub startDaemon
{
    parse_conf();

    defined ($pid = fork)
	or die ("Fork impossible : $!");
    
    # Code effectif du daemon
    if ($pid == 0)
    {
	socket (SERVEUR, PF_INET, SOCK_STREAM, getprotobyname('tcp'));
	setsockopt (SERVEUR, SOL_SOCKET, SO_REUSEADDR, 1);
	$mon_adresse = sockaddr_in ($conf{port}, INADDR_ANY)
	    or die "sockaddr_in ($!)";
	bind (SERVEUR, $mon_adresse)
	    or die "bind ($!)";
	listen (SERVEUR, SOMAXCONN)
	    or die "listen ($!)";

	eventlog("start","local",$conf{port});

	while(1) # Boucle du daemon
	{
	    # Le 'next if $!{EINTR};' permet de relancer accept s'il a été interrompu par un signal.
	    accept (CLIENT, SERVEUR)
		or do {next if $!{EINTR}; die "accept ($!)";};
	    
	    defined($pid = fork)
		or die "Fork impossible : $!";

	    if ($pid == 0) # Ouvrier
	    {

		senderror(503) unless $nbOuvriers < $conf{clients};

		autoflush CLIENT 1;
 		autoflush STDOUT 1;
		
		# Récupération de l'ip et du port client
		$sockaddr = getpeername CLIENT;
		($clientPort, $clientIp) = unpack_sockaddr_in $sockaddr;
		$clientIp = inet_ntoa $clientIp;

#		print STDOUT "IP : $clientIp Port : $clientPort\n";
 
		my @req = acceptrequest();



		okMessage(@req);

		closeouvrier(0);
	    }
	    else # Répartiteur
	    {
		$nbRequetesTraitees ++;
		$nbOuvriers ++;

		close (CLIENT);
	    }

	}
    }

    # Dans le père on conserve le PID du daemon
    # dans le fichier .daemon.pid (à la manière d'apache dans /var/run).
    # On protège le fichier en écriture pour éviter toute suppression 
    # par l'utlisateur.
    else
    {
	open(PID_FILE, ">", $pidFile)
	    or die "open $!";
	print PID_FILE $pid;
	chmod 0400, $pidFile;
	exit 0;
    }
}

# Log la chaîne passée en paramètre
sub eventlog
{
    ($type, $machine, $requete, $projection, $reponse) = @_;

    open(LOG_FILE, ">>$conf{logfile}")
	or die "open $!";

#    print LOG_FILE time,";","$_[0]\n";
    print LOG_FILE join (";",  time, $type, $machine, $requete, $projection, $reponse,"\n");

    close LOG_FILE;
}

# Retourne un message 200 et une page contenant le nom de la requête.
sub okMessage
{
    sendstatus (200, $_[0]);

    open(RESSOURCE, "<", $conf{default});

    while(<RESSOURCE>)
    {
	print CLIENT "$_\n";
    }

    # print CLIENT "<html>\n".
    # 	" <body>\n".
    # 	"  <h1> $_[1] </h1>\n".
    # 	" </body>\n".
    # 	"</html>";
}

sub sendstatus
{
    print CLIENT "HTTP/1.1 $_[0] $reason_phrases{$_[0]}".$EOR;
    eventlog("get", $clientIp, $_[1], $projection, $_[0]);
}

# Retourne une page d'erreur au client
sub senderror
{
    my $stat_code = $_[0];
    my $requete = $_[1];

    sendstatus($stat_code, $requete);

    print CLIENT "<html>\n".
	" <head>\n".
	"  <title>$stat_code $reason_phrases{$stat_code}</title>\n".
	" </head>\n".
	" <body>\n".
	"  <h1>$reason_phrases{$stat_code}</h1>\n".
	" </body>\n".
	"</html>\n";

    closeouvrier(1);
}

# Termine l'ouvrier avec un code de retour
# suivant le paramètre passé
sub closeouvrier
{
    $nbOuvriers --;
    close(CLIENT);
    close (SERVEUR);

    exit $_[0];
}

# Filtre le header de la requete client
# Si la requête est mal formée, retourne un message d'erreur au client,
# sinon retourne un tableau contenant la ligne de requete et la ressource demandée
# FIXME : la ligne Host:... peut être à n'importe quelle position après la première ligne.
sub acceptrequest
{
    # regex meta = {}[]()^$.|*+?\
    autoflush CLIENT 1;

    my @req;

    <CLIENT> =~ /(?i)(^((?-i)GET)\s+(\/[^\s]*)\s+HTTP\/1\.1)\r?\n/
	or senderror(400);

    # requête
    $req[0] = $1;
    # ressource
    $req[1] = $3;

#    while(<CLIENT> !~ /(?i)^host:\s*[^\s]*\s*\r?\n/){}
    <CLIENT> =~ /(?i)^host:\s*[^\s]*\s*\r?\n/
	or senderror(400, $req[0]);
    while(<CLIENT> !~ /^\r?\n/)
    {}

    return @req;
}

sub parse_conf {
    open (CONF, "comanche.conf")
	or die ("open comanche.conf ($!)");

    foreach (<CONF>) {
	if (/^set/){
	    $_ =~ /^set\s([^\s]*)\s([^\s]*)/;
	    $conf{$1} = $2;
	}
	
	if (/^route/){
	    $_ =~ /^route\s([^\s]*)\sto\s([^\s]*)/;
	#    verifier_fichier($2);
	    push(@relative_route,$1);
	    push(@absolute_route,$2);
	}

	if(/^exec/) {
	    $_ =~ /^exec\s([^\s]*)\sfrom\s([^\s]*)/;
	#    verifier_fichier($2);
	    push(@relative_exec,$1);
	    push(@absolute_exec,$2);
	}

    }

    close(CONF);
}

# Envoi le signal passé en paramètre au processus dont le pid
# est contenu dans le fichier $pidFile
sub sendSignal
{
    open(PID_FILE, "<", $pidFile)
	or die ("open $!");
    $daemonPid = <PID_FILE>;
    kill "$_[0]" => $daemonPid;
    close PID_FILE;

    # attente de la fin du daemon et supressin du fichier $pidFile
    if ($_[0] =~ /$signaux{stop}/)
    {
	while (kill 0 => $daemonPid) {print "."; select(undef,undef,undef,0.5);}
	print "stopped\n";
	unlink($pidFile);
    }

    exit 0;
}

sub FOSSOYEUR{
    local $!;
    my $child;

    while (($child = waitpid (-1, &WNOHANG)) > 0 ){
	$nbOuvriers --;
    }
    $SIG{CHLD} = \&FOSSOYEUR;
}

sub PRINTSTATUS
{
    print STDOUT "status !\n";
}


sub STOPDAEMON
{
    while(wait > 0){}
    close (SERVEUR);
    eventlog("stop","local",$conf{port});
    exit 0;
}
