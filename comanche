#!/usr/bin/perl

use Socket;
use POSIX qw(:sys_wait_h strftime);
use File::MimeInfo;

$ARGV[0] =~ /^(start|stop|status)$/ or die ("$0 [start|stop|status]\n");
$action = $ARGV[0];

$EOL = "\015\012";
$EOR = $EOL x 2;
$confFile = "comanche.conf";
$pidFile = ".comanche.pid";

@proj_type;
@relative_path;
@absolute_path;

%reason_phrases = (
    200, "OK",
    400, "Bad Request",
    404, "Not Found",
    503, "Service Unavailable"
    );

%signaux = (
    status, "USR1",
    stop, "USR2"
    );

# prise en compte des la mort des ouvriers
$SIG{CHLD} = \&FOSSOYEUR;
$SIG{$signaux{status}} = \&PRINTSTATUS;
$SIG{$signaux{stop}} = \&STOPDAEMON;

$recues = 0;
$traitees = 0;

select STDOUT;
$| = 1;

$action =~ /^start$/ && do {(-f $pidFile) ? die "Une instance de comanche existe déjà.\n" : startDaemon()};

$action =~ /^(status|stop)$/ && do {(-f $pidFile) ? sendSignal($signaux{$action}) : die "Le service n'est pas démarré.\n"};

sub startDaemon
{
    parse_conf();

    defined ($pid = fork)
	or die ("Fork impossible : $!");
    
    # Code effectif du daemon
    if ($pid == 0)
    {
	socket (SERVEUR, PF_INET, SOCK_STREAM, getprotobyname('tcp'));
	setsockopt (SERVEUR, SOL_SOCKET, SO_REUSEADDR, 1);
	$mon_adresse = sockaddr_in ($conf{port}, INADDR_ANY)
	    or die "sockaddr_in ($!)";
	bind (SERVEUR, $mon_adresse)
	    or die "bind ($!)";
	listen (SERVEUR, SOMAXCONN)
	    or die "listen ($!)";

	eventlog("start","local",$conf{port});

	while(1)
	{
	    # on reprend la boucle si interruption système
	    accept (CLIENT, SERVEUR)
		or do {next if $!{EINTR}; die "accept ($!)";};
	    
	    defined($pid = fork)
		or die "Fork impossible : $!";

	    if ($pid == 0) # Ouvrier
	    {

		senderror(503) unless scalar keys %children < $conf{clients};

		autoflush CLIENT 1;
 		autoflush STDOUT 1;
		
		# Récupération de l'ip du client
		$sockaddr = getpeername CLIENT;
		($port_client, $ip_client) = unpack_sockaddr_in $sockaddr;
		$ip_client = inet_ntoa $ip_client;

		my ($requete, $ressource_rel) = acceptrequest();
		
		my ($ressource_loc, $ressource_type) = getressource($ressource_rel);

#		print STDOUT "res0: $res[0] res1: $res[1]\n"; # DEBUG

	        # @rep = construirereponse($ressource_loc, $ressource_type , $ressource_rel);
	        my ($header_infos, $contenu) = construirereponse($ressource_loc, $ressource_type , $ressource_rel);
		
#		print STDOUT "rep : ",@rep,"\n"; # DEBUG

		if ($contenu)
		{
#		    print STDOUT "rep OK !\n"; # DEBUG
		    sendheader(200, $requete, $header_infos);
		    print CLIENT $contenu;
		}
		else
		{
#		    print STDOUT "rep PAS OK !\n"; # DEBUG
		    senderror(404, $req[0]);
		}

		closeouvrier(0);
	    }
	    else # Répartiteur
	    {
		$nbRequetesTraitees ++;
		$children{$pid} = 1;
		close (CLIENT);
	    }

	}
    }

    # Dans le père on conserve le PID du daemon
    # dans le fichier .daemon.pid (à la manière d'apache dans /var/run).
    # On protège le fichier en écriture pour éviter toute suppression 
    # par l'utlisateur.
    else
    {
	open(PID_FILE, ">", $pidFile)
	    or die "open $!";
	print PID_FILE $pid;
	chmod 0400, $pidFile;
	exit 0;
    }
}

# Param : requête (chemin relatif demandé)
# Retourne : tableau {ressource locale , type (stat ou dyn)}
# ou undef si aucune correpondance n'est trouvée.
sub getressource
{
    my ($ressource_rel, $ressource_loc, $type);

    $ressource_rel = $_[0];

    foreach (0..$#relative_path)
    {
	if ($ressource_rel =~ m{$relative_path[$_]})
	{
	    my $nom_res = $1;

	    # Faute de mieux, on remplace \1 par ce qui match
	    $ressource_loc = $absolute_path[$_] =~ s{\\1}{$nom_res}r;
	    $type = $proj_type[$_];

	    return ($ressource_loc, $type);
	}
    }
    return undef;
}

# Prend en paramètre (ressource, type)
sub construirereponse
{
    my $header_infos;
    my $contenu;

    if (defined @_)
    {
	my ($ressource, $type) = @_;
	my $mime;

	if (-f $ressource)
	{
	    ($mime, $contenu) = lireressource($ressource, $type);
	}
	elsif (-d $ressource)
	{
	    local $/ = "/";
	    chomp($ressource);
	    local $/ = "\n";

	    if (-f $ressource."/".$conf{index})
	    {
		$projection = $ressource."/".$conf{index};
		($mime, $contenu) = lireressource($projection, $type);
	    }
	    else
	    {
		$mime = "text/html";
		# TODO
		$contenu = lister($ressource);
	    }
	}

	# lireressource() retourne undef si le type mime est invalide
	return undef if (! $contenu);

	$header_infos = "Content-Type: ".$mime;
	
	return ($header_infos, $contenu);
    }
    return undef;
}

# Retourne le résultat (statique ou dynamique) d'une ressource
# Param : chemin d'un fichier existant
sub lireressource
{
    my ($ressource, $type) = @_;
    
    my ($mime, $contenu);

    if ($type eq "stat")
    {
	$mime = mimetype($ressource);

#	print STDOUT $mime."\n";
	
	return undef if ($mime !~ m{((text/(plain|html))|(image/(jpeg|pjpeg)))});
#	print STDOUT $mime."\n" if ($mime !~ m{((text/(plain|html))|(image/(jpeg|pjpeg)))});

	open (FICHIER, "<", $ressource);
	while (<FICHIER>)
	{
	    $contenu .= $_;
	}
	close (FICHIER);
    }
    else
    {
	# TODO vraie gestion de la convention CGI
	$mime = "text/html";
	$contenu = `$ressource`;
    }
    return ($mime, $contenu);
}

sub lister
{
    return "<html><body><h1></h1></body></html>\n";
}

# Ecrit dans le fichier de log
# Param : (type, machine, (port|requete), projection, statuscode)
sub eventlog
{
    open(LOG_FILE, ">>$conf{logfile}")
	or die "open $!";

    print LOG_FILE join (";",  time,@_,"\n");

    close LOG_FILE;
}

# Param : (statuscode, requete, Infos header)
sub sendheader
{    
    print CLIENT "HTTP/1.1 $_[0] $reason_phrases{$_[0]}".$EOL.
	"$_[2]".$EOR;

    eventlog("get", $ip_client, $_[1], $projection, $_[0]);
}

# Envoi une page d'erreur au client et ferme la connection
# Param : (statuscode, requete)
sub senderror
{
    my $stat_code = $_[0];
    my $requete = $_[1];

    sendheader($stat_code, $requete);

    print CLIENT "<html>\n".
	" <head>\n".
	"  <title>$stat_code $reason_phrases{$stat_code}</title>\n".
	" </head>\n".
	" <body>\n".
	"  <h1>$reason_phrases{$stat_code}</h1>\n".
	" </body>\n".
	"</html>\n";

    closeouvrier(1);
}

# Termine l'ouvrier avec un code de retour
# suivant le paramètre passé
sub closeouvrier
{
    close(CLIENT);
    close (SERVEUR);
    exit $_[0];
}

# Filtre le header de la requete client
# Si la requête est mal formée, retourne un message d'erreur au client,
# sinon retourne un tableau contenant la ligne de requete et la ressource demandée
sub acceptrequest
{
    # regex meta = {}[]()^$.|*+?\
    autoflush CLIENT 1;

    <CLIENT> =~ /(?i)(^((?-i)GET)\s+(\/[^\s]*)\s+HTTP\/1\.1)\r?\n/
	or senderror(400);

    # requête
    my $requete = $1;
    # ressource
    my $ressource = $3;

    my $ok;
    while(1)
    {
	$ligne = <CLIENT>;
	$ok = 1 if ($ligne =~ /(?i)^host:\s*[^\s]*\s*\r?\n/);

	if ($ligne =~ /^\r?\n/)
	{
	    return ($requete, $ressource) if $ok;
	    senderror(400, $requete);
	}
    }
}

# Lit et charge la configuration de $confFile
sub parse_conf {
    open (CONF, "$confFile")
	or die ("open ($!)");

    while (<CONF>) {
	if (/^\s*(#|$)/)
	{next}

	elsif (/^\s*set\s*(port|default|index|logfile|clients)\s*([^\s#]*)\s*(#.*|$)/)
	{
	    $conf{$1} = $2;
	}

	elsif (/^\s*route\s*([^\s#]*)\s*to\s*([^\s#]*)\s*(#.*|$)/)
	{
	    push(@proj_type,"stat");
	    push(@relative_path,$1);
	    push(@absolute_path,$2);
	}

	elsif (/^\s*exec\s*([^\s#]*)\s*from\s*([^\s#]*)\s*(#.*|$)/)
	{
	    push(@proj_type,"dyn");
	    push(@relative_path,$1);
	    push(@absolute_path,$2);
	}
	else
	{
	    chomp($_);
	    die ("$confFile : erreur de syntaxe ligne $. : '$_'\n");
	}
    }
    close(CONF);
}

# Envoi le signal passé en paramètre au processus dont le pid
# est contenu dans le fichier $pidFile
# Param : signal à envoyer
sub sendSignal
{
    open(PID_FILE, "<", $pidFile)
	or die ("open $!");
    $daemonPid = <PID_FILE>;
    kill "$_[0]" => $daemonPid;
    close PID_FILE;

    # attente de la fin du daemon et supression du fichier $pidFile
    if ($_[0] =~ /$signaux{stop}/)
    {
	while (kill 0 => $daemonPid) {print "."; select(undef,undef,undef,0.5);}
	print "stopped\n";
	unlink($pidFile);
    }

    exit 0;
}

# Enregistre la mort d'un ouvrier
sub FOSSOYEUR{
    local $!;
    my $pid;

    while (($pid = waitpid (-1, &WNOHANG)) > 0 )
    {
	delete $children{$pid};
    }

    $SIG{CHLD} = \&FOSSOYEUR;
}

# Ecrit le status sur la sortie standard
# BUG : Methode utilisée écrit sur la sortie
# du terminal utilisé pour démarrer le serveur
sub PRINTSTATUS
{
    @ouvriers = keys %children;
    print STDOUT "PID du daemon : $$\n".
	"Requêtes - reçues: $recues, traitées: $traitees\n".
	scalar @ouvriers." ouvriers actifs : (@ouvriers)\n";
}

# Arrête le serveur proprement
sub STOPDAEMON
{
    while(wait > 0){}
    close (SERVEUR);
    eventlog("stop","local",$conf{port});
    exit 0;
}
