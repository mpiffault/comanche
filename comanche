#!/usr/bin/perl

use Socket;
use POSIX qw(:sys_wait_h strftime);

$EOL = "\015\012";
$EOR = $EOL x 2;
$pidFile = ".comanche.pid";

$ARGV[0] =~ /^(start|stop|status)$/ or printusage();
$action = $ARGV[0];

@relative_route;
@absolute_route;

@relative_exec;
@absolute_exec;

%reason_phrases = (
    200, "OK",
    400, "Bad Request",
    503, "Service Unavailable"
    );

%signaux = (
    status, "USR1",
    stop, "USR2"
    );

# prise en compte des la mort des ouvriers
$SIG{CHLD} = \&FOSSOYEUR;
$SIG{$signaux{status}} = \&PRINTSTATUS;
$SIG{$signaux{stop}} = \&STOPDAEMON;

select STDOUT;
$| = 1;

$action =~ /^start$/ && do {(-f $pidFile) ? print "Un instance de comanche existe déjà.\n" : startDaemon()};

$action =~ /^(status|stop)$/ && do {(-f $pidFile) ? sendSignal($signaux{$action}) : print "Le service n'est pas démarré.\n"};

sub printusage
{
    print "$0 [start|stop]\n";
    exit 1;
}

sub startDaemon
{
    parse_conf();

    defined ($pid = fork)
	or die ("Fork impossible : $!");
    
    # Code effectif du daemon
    if ($pid == 0)
    {
	socket (SERVEUR, PF_INET, SOCK_STREAM, getprotobyname('tcp'));
	setsockopt (SERVEUR, SOL_SOCKET, SO_REUSEADDR, 1);
	$mon_adresse = sockaddr_in ($conf{port}, INADDR_ANY)
	    or die "sockaddr_in ($!)";
	bind (SERVEUR, $mon_adresse)
	    or die "bind ($!)";
	listen (SERVEUR, SOMAXCONN)
	    or die "listen ($!)";

	eventlog("start;local;$conf{port}");

	while(1) # Boucle du daemon
	{
	    # Le 'next if $!{EINTR};' permet de relancer accept s'il a été interrompu par un signal.
	    accept (CLIENT, SERVEUR)
		or do {next if $!{EINTR}; die "accept ($!)";};
	    
	    defined($pid = fork)
		or die "Fork impossible : $!";

	    if ($pid == 0) # Ouvrier
	    {

		senderror(503) unless $nbOuvriers < $conf{clients};

		autoflush CLIENT 1;
 		autoflush STDOUT 1;
		
		# Récupération de l'ip et du port client
		$sockaddr = getpeername CLIENT;
		($clientPort, $clientIp) = unpack_sockaddr_in $sockaddr;
		$clientIp = inet_ntoa $clientIp;

		print STDOUT "IP : $clientIp Port : $clientPort\n";
 
		my $requete = acceptrequest();
		okMessage($requete);

		closeouvrier(0);
	    }
	    else # Répartiteur
	    {
		$nbRequetesTraitees ++;
		$nbOuvriers ++;

		close (CLIENT);
	    }

	}
    }

    # Dans le père on conserve le PID du daemon
    # dans le fichier .daemon.pid (à la manière d'apache dans /var/run).
    # On protège le fichier en écriture pour éviter toute suppression 
    # par l'utlisateur.
    else
    {
	open(PID_FILE, ">", $pidFile)
	    or die "open $!";
	print PID_FILE $pid;
	chmod 0400, $pidFile;
	exit 0;
    }
}

# Log la chaîne passée en paramètre
sub eventlog
{
    open(LOG_FILE, ">>$conf{logfile}")
	or die "open $!";

    print LOG_FILE time,";","$_[0]\n";

    close LOG_FILE;
}

# Retourne un message 200 et une page contenant le nom de la requête.
sub okMessage
{
    sendstatus (200);

    print CLIENT "<html>\n".
	" <body>\n".
	"  <h1> $_[0] </h1>\n".
	" </body>\n".
	"</html>";

    eventlog("get;$clientIp;$_[0];;200");
}

sub sendstatus
{
    print CLIENT "HTTP/1.1 $_[0] $reason_phrases{$_[0]}".$EOR;
}

sub senderror
{
    sendstatus($_[0]);

    print CLIENT "<html>\n".
	" <head>\n".
	"  <title>$_[0] $reason_phrases{$_[0]}</title>\n".
	" </head>\n".
	" <body>\n".
	"  <h1>$reason_phrases{$_[0]}</h1>\n".
	" </body>\n".
	"</html>\n";

    eventlog("get;$clientIp;$_[1];$prjection;$_[0];");
    closeouvrier(1);
}

# Termine l'ouvrier avec un code de retour
# suivant le paramètre passé
sub closeouvrier
{
    $nbOuvriers --;
    close(CLIENT);
    close (SERVEUR);

    exit $_[0];
}

# Accepte la requete d'un client
# Si la requête est mal formée, retourne un message d'erreur au client.
# 
# FIXME : la ligne Host:... peut être à n'importe quelle position après la première ligne.
sub acceptrequest
{
    # regex meta = {}[]()^$.|*+?\
    autoflush CLIENT 1;
    <CLIENT> =~ /(?i)^((?-i)GET)\s+(\/[^\s]*)\s+HTTP\/1\.1\r?\n/
	or senderror(400);

    my $requete = $2;

#    while(<CLIENT> !~ /(?i)^host:\s*[^\s]*\s*\r?\n/){}
    <CLIENT> =~ /(?i)^host:\s*[^\s]*\s*\r?\n/
	or senderror(400, $requete);
    while(<CLIENT> !~ /^\r?\n/)
    {}

    return $requete;
}

sub parse_conf {
    open (CONF, "comanche.conf")
	or die ("open comanche.conf ($!)");
    foreach (<CONF>) {
	if(/^set/){
	    $_ =~ /^set\s([^\s]*)\s([^\s]*)/;
	    $conf{$1} = $2;
	}
    }
    close(CONF);
}

# Envoi le signal passé en paramètre au processus dont le pid
# est contenu dans le fichier $pidFile
sub sendSignal
{
    open(PID_FILE, "<", $pidFile)
	or die ("open $!");
    $daemonPid = <PID_FILE>;
    kill "$_[0]" => $daemonPid;
    close PID_FILE;

    # attente de la fin du daemon et supressin du fichier $pidFile
    if ($_[0] =~ /$signaux{stop}/)
    {
	while (kill 0 => $daemonPid) {print "."; select(undef,undef,undef,0.5);}
	print "stopped\n";
	unlink($pidFile);
    }

    exit 0;
}

sub FOSSOYEUR{
    local $!;
    my $child;

    while (($child = waitpid (-1, &WNOHANG)) > 0 ){
	$nbOuvriers --;
    }
    $SIG{CHLD} = \&FOSSOYEUR;
}

sub PRINTSTATUS
{
    print STDOUT "status !\n";
}


sub STOPDAEMON
{
    while(wait > 0){}
    close (SERVEUR);
    eventlog("stop;local;$conf{port}");
    exit 0;
}
