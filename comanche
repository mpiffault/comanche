#!/usr/bin/perl

use Socket;
use POSIX qw(:sys_wait_h strftime);
use File::MimeInfo;

$ARGV[0] =~ /^(start|stop|status)$/ or die ("$0 [start|stop|status]\n");
$action = $ARGV[0];

$EOL = "\015\012";
$EOR = $EOL x 2;
$confFile = "comanche.conf";
$pidFile = ".comanche.pid";

@proj_type;
@relative_path;
@absolute_path;

%reason_phrases = (
    200, "OK",
    400, "Bad Request",
    404, "Not Found",
    503, "Service Unavailable"
    );

%signaux = (
    status, "USR1",
    stop, "USR2"
    );

# prise en compte des la mort des ouvriers
$SIG{CHLD} = \&FOSSOYEUR;
$SIG{$signaux{status}} = \&PRINTSTATUS;
$SIG{$signaux{stop}} = \&STOPDAEMON;

$recues = 0;
$traitees = 0;

select STDOUT;
$| = 1;

$action =~ /^start$/ && do {(-f $pidFile) ? die "Une instance de comanche existe déjà.\n" : startDaemon()};

$action =~ /^(status|stop)$/ && do {(-f $pidFile) ? sendSignal($signaux{$action}) : die "Le service n'est pas démarré.\n"};

sub startDaemon
{
    parse_conf();

    defined ($pid = fork)
	or die ("Fork impossible : $!");
    
    # Code effectif du daemon
    if ($pid == 0)
    {
	socket (SERVEUR, PF_INET, SOCK_STREAM, getprotobyname('tcp'));
	setsockopt (SERVEUR, SOL_SOCKET, SO_REUSEADDR, 1);
	$mon_adresse = sockaddr_in ($conf{port}, INADDR_ANY)
	    or die "sockaddr_in ($!)";
	bind (SERVEUR, $mon_adresse)
	    or die "bind ($!)";
	listen (SERVEUR, SOMAXCONN)
	    or die "listen ($!)";

	eventlog("start","local",$conf{port});

	while(1)
	{
	    # on reprend la boucle si interruption système
	    accept (CLIENT, SERVEUR)
		or do {next if $!{EINTR}; die "accept ($!)";};
	    
	    defined($pid = fork)
		or die "Fork impossible : $!";

	    if ($pid == 0) # Ouvrier
	    {

		senderror(503) unless scalar keys %children < $conf{clients};

		autoflush CLIENT 1;
 		autoflush STDOUT 1;
		
		# Récupération de l'ip du client
		$sockaddr = getpeername CLIENT;
		($port_client, $ip_client) = unpack_sockaddr_in $sockaddr;
		$ip_client = inet_ntoa $ip_client;

		my @req = acceptrequest();
		
		
		@res = getressource($req[1]);

	        $rep = construirereponse(@res);
		
		if ($rep)
		{
		    sendstatus(200, $req[0]);
		    print CLIENT $rep;
		}
		else
		{
		    senderror(404, $req[0]);
		}

		closeouvrier(0);
	    }
	    else # Répartiteur
	    {
		$nbRequetesTraitees ++;
		$children{$pid} = 1;
		close (CLIENT);
	    }

	}
    }

    # Dans le père on conserve le PID du daemon
    # dans le fichier .daemon.pid (à la manière d'apache dans /var/run).
    # On protège le fichier en écriture pour éviter toute suppression 
    # par l'utlisateur.
    else
    {
	open(PID_FILE, ">", $pidFile)
	    or die "open $!";
	print PID_FILE $pid;
	chmod 0400, $pidFile;
	exit 0;
    }
}

# Prend en paramètre (ressource, type)
sub construirereponse
{
    my $reponse;

    if (defined $_[0])
    {
	my $ressource = $_[0];

	
	# TODO page de liens si pas d'index
	if (-d $ressource)
	{
	    local $/ = "/";

	    chomp($ressource);
	    $ressource = $ressource."/".$conf{index};
	}

	return undef if (! -f $ressource);

	if ($_[1] eq "stat")
	{
	    $reponse = lirefichier($ressource);
	}
	else
	{
	    $reponse = `$ressource`;
	}
    }

    return $reponse;
}

# Ecrit dans le fichier de log
# Param : (type, machine, (port|requete), projection, statuscode)
sub eventlog
{
    open(LOG_FILE, ">>$conf{logfile}")
	or die "open $!";

    print LOG_FILE join (";",  time,@_,"\n");

    close LOG_FILE;
}

# Param : (statuscode, requete)
sub sendstatus
{
    
    print CLIENT "HTTP/1.1 $_[0] $reason_phrases{$_[0]}".$EOR;
    eventlog("get", $ip_client, $_[1], $projection, $_[0]);
}

# Envoi une page d'erreur au client et ferme la connection
# Param : (statuscode, requete)
sub senderror
{
    my $stat_code = $_[0];
    my $requete = $_[1];

    sendstatus($stat_code, $requete);

    print CLIENT "<html>\n".
	" <head>\n".
	"  <title>$stat_code $reason_phrases{$stat_code}</title>\n".
	" </head>\n".
	" <body>\n".
	"  <h1>$reason_phrases{$stat_code}</h1>\n".
	" </body>\n".
	"</html>\n";

    closeouvrier(1);
}

# Retourne le contenu d'un fichier
# Param : chemin d'un fichier existant
sub lirefichier
{
    my $contenu;

    open (FICHIER, "<", $_[0]);
    while (<FICHIER>)
    {
	$contenu .= $_;
    }
    close (FICHIER);

    return $contenu;
}

# Termine l'ouvrier avec un code de retour
# suivant le paramètre passé
sub closeouvrier
{
    close(CLIENT);
    close (SERVEUR);
    exit $_[0];
}

# Filtre le header de la requete client
# Si la requête est mal formée, retourne un message d'erreur au client,
# sinon retourne un tableau contenant la ligne de requete et la ressource demandée
# BUG : la ligne Host:... peut être à n'importe quelle position
# après la première ligne. Erreur avec wget par exemple.
sub acceptrequest
{
    # regex meta = {}[]()^$.|*+?\
    autoflush CLIENT 1;

    my @req;

    <CLIENT> =~ /(?i)(^((?-i)GET)\s+(\/[^\s]*)\s+HTTP\/1\.1)\r?\n/
	or senderror(400);

    # requête
    $req[0] = $1;
    # ressource
    $req[1] = $3;

    my $ok;
    while(1)
    {
	$ligne = <CLIENT>;
	$ok = 1 if ($ligne =~ /(?i)^host:\s*[^\s]*\s*\r?\n/);

	if ($ligne =~ /^\r?\n/)
	{
	    return @req if $ok;
	    senderror(400, $req[0]);
	}
    }


#   while(<CLIENT> !~ /(?i)^host:\s*[^\s]*\s*\r?\n/){}
    # <CLIENT> =~ /(?i)^host:\s*[^\s]*\s*\r?\n/
    # 	or senderror(400, $req[0]);

    # while(<CLIENT> !~ /^\r?\n/)
    # {}

    # return @req;
}

# Param : requête (chemin relatif demandé)
# Retourne : tableau {ressource locale , type (stat ou dyn)}
# ou undef si aucune correpondance n'est trouvée.
sub getressource
{
    my @res;
    $res[0] = $_[0];

    foreach (0..$#relative_path)
    {
	if ($res[0] =~ m{$relative_path[$_]})
	{
	    $nom_res = $1;

	    $res[0] = $absolute_path[$_] =~ s{\\1}{$nom_res}r;
	    
	    $res[1] = $proj_type[$_];
	    return @res;
	}
    }
    return undef;
}

# Lit et charge la configuration de $confFile
sub parse_conf {
    open (CONF, "$confFile")
	or die ("open ($!)");

    while (<CONF>) {
	if (/^\s*(#|$)/)
	{next}

	elsif (/^\s*set\s*(port|default|index|logfile|clients)\s*([^\s#]*)\s*(#.*|$)/)
	{
	    $conf{$1} = $2;
	}

	elsif (/^\s*route\s*([^\s#]*)\s*to\s*([^\s#]*)\s*(#.*|$)/)
	{
	    push(@proj_type,"stat");
	    push(@relative_path,$1);
	    push(@absolute_path,$2);
	}

	elsif (/^\s*exec\s*([^\s#]*)\s*from\s*([^\s#]*)\s*(#.*|$)/)
	{
	    push(@proj_type,"dyn");
	    push(@relative_path,$1);
	    push(@absolute_path,$2);
	}
	else
	{
	    chomp($_);
	    die ("$confFile : erreur de syntaxe ligne $. : '$_'\n");
	}
    }
    close(CONF);
}

# Envoi le signal passé en paramètre au processus dont le pid
# est contenu dans le fichier $pidFile
# Param : signal à envoyer
sub sendSignal
{
    open(PID_FILE, "<", $pidFile)
	or die ("open $!");
    $daemonPid = <PID_FILE>;
    kill "$_[0]" => $daemonPid;
    close PID_FILE;

    # attente de la fin du daemon et supression du fichier $pidFile
    if ($_[0] =~ /$signaux{stop}/)
    {
	while (kill 0 => $daemonPid) {print "."; select(undef,undef,undef,0.5);}
	print "stopped\n";
	unlink($pidFile);
    }

    exit 0;
}

# Enregistre la mort d'un ouvrier
sub FOSSOYEUR{
    local $!;
    my $pid;

    while (($pid = waitpid (-1, &WNOHANG)) > 0 )
    {
	delete $children{$pid};
    }

    $SIG{CHLD} = \&FOSSOYEUR;
}

# Ecrit le status sur la sortie standard
# BUG : Methode utilisée écrit sur la sortie
# du terminal utilisé pour démarrer le serveur
sub PRINTSTATUS
{
    @ouvriers = keys %children;
    print STDOUT "PID du daemon : $$\n".
	"Requêtes - reçues: $recues, traitées: $traitees\n".
	scalar @ouvriers." ouvriers actifs : (@ouvriers)\n";
}

# Arrête le serveur proprement
sub STOPDAEMON
{
    while(wait > 0){}
    close (SERVEUR);
    eventlog("stop","local",$conf{port});
    exit 0;
}
